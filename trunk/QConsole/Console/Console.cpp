#include <QList>
#include <QString>
#include <QTextStream>
#include <Executer.h>
#include <Interceptor.h>
#include <Injector.h>
#include <InterceptorInjector.h>

#include "Console.h"

Console::Console (Executer *e,
                  Interpreter *it):
    executer(e), interpreter(it), last_output_type(Console::NONE)
{
    history = new QList<QString>(); // Create history list
    interceptor = new QList<Interceptor*>();
    // Inject it into Python environment
    // @see Injector::inject(..) and Inject::introduce(..)
    // for details

    InterceptorInjector injector;
    introduce(&injector);

    QString out = "out";
    QString err = "err";

    Interceptor *ierr = new Interceptor(Console::STDERR);
    inject((void*) ierr, err, &injector);

    Interceptor *iout = new Interceptor(Console::STDOUT);
    inject((void*) iout, out, &injector);

    interceptor->push_back(ierr);
    interceptor->push_back(iout);
    // This script replaces default streams (stdout and stderr)
    // with class (Redirect) passing all messages to our interceptor
    QString redirector_class =
            "import sys                        \n"
            "class Redirect:                   \n"
            "   def __init__(self, stream, intrcp):\n"
            "       self.stream = stream       \n"
            "       self.intrcp = intrcp       \n"
            "   def write(self, message):      \n"
            "       message = message.strip()  \n"
            "       if message != \"\":        \n"
            "           self.intrcp.grab(message)\n"
            "       #self.stream.write(message)\n"   // We turn off
            "       #self.stream.flush()       \n";  // redirection to
    // default stream
    QString redirection =
            "sys.stderr = Redirect(sys.stderr, "+err+")\n"
            "sys.stdout = Redirect(sys.stdout, "+out+")\n";
    executer->execute(redirector_class);
    executer->execute(redirection);
}

void Console::inject(void *obj, QString name, Injector *i) {
    object main_namespace = executer->get_main_namespace();
    i->inject(name, main_namespace, obj);
}

void Console::introduce(Injector *i) {
    object main_namespace = executer->get_main_namespace();
    i->introduce(main_namespace);
}

Console::~Console () {
    delete executer;
    delete interpreter;
    delete interceptor;
    delete history;
}

QString Console::evaluate(QString command) {
    // This method does something like this:
    // user's command --> interpreted command -->
    // --> output generated by interpreted command
    // f.eg.
    // set turbo_engine, MAX -->
    // --> <call func="set" args=2>
    //          <arg>turbo_engine</arg>
    //          <arg>MAX</arg>
    //     </call>
    // --> Yes, sir!
    while(command.endsWith(' '))
        command = command.remove(command.size()-1, 1);

    //LOG4CXX_INFO(logger,
    //    "Evaluating \"" << command << "\"");

    if(!command.isEmpty()) {
        int cmd_index = history->indexOf(command);
        if(cmd_index >= 0)
            history->removeAt(cmd_index); // Move existing command from pos
                                          // cmd_index to end of the list
        history->push_back(command);
    }

    QString interpreted_command =
            interpreter->interprete(command);

    QString output;
    bool not_found = true;

    if(!interpreted_command.isEmpty())
        executer->execute(interpreted_command);

    for(QList<Interceptor*>::iterator i = interceptor->begin();
        i != interceptor->end();
        i++) { // Find interceptor that has grabbed output
            QString o = (*i)->output();
            if(o != "" && not_found) {
                output = o;
                last_output_type = (*i)->get_type();
                not_found = false; // We do this to clear all interceptors in list
            }
            (*i)->clear();
        }
    return output;
}
